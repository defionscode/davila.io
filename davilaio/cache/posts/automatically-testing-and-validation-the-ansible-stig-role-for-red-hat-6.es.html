<h2>Introduction</h2>
<p>One of my current projects at <a href="http://ansible.com/">Ansible</a> is to devise and maintain a collection of open source and free security-hardening-through-ansible repositories<!-- TEASER_END --> in collaboration with Daniel Shepherd from <a href="http://mindpointgroup.com/">MindPoint Group</a> (a badass IT security shop). Officially, it is an <strong>Ansible + MindPoint Group</strong> project with Dan and I at the helm.</p>
<p>Our initial effort has been to develop an Ansible role that applies the current STIG baselines to Red Hat Enterprise Linux 6 (RHEL 6) operating systems. Our end goal is to provide Ansible roles that apply security baselines for all of the major standards and for more than just the OS layer (i.e. application and database).</p>
<p>This effort is intended to build upon the official articles published Ansible and MindPoint Group, so I want to get into the technical deep dive right away.</p>
<p>I'll cover the two major components involved in this development effort: the development of the role itself, and the testing suite we currently use to validate the STIG can be properly applied.</p>
<h2>RHEL6-STIG Role</h2>
<p>For the sake of my sanity (and length) I won't go into all of the bits that constitute the role, nor will I talk about what is in the README, if you want to surf through the code, it is openly available on GitHub.</p>
<p>The role has the ability to detect and remediate:</p>
<ul>
<li>100% of CAT 1</li>
<li>91% of CAT 2, and</li>
<li>82% of CAT 3 benchmarks</li>
</ul>
<p>of the DISA STIG for Red Hat Enterprise Linux 6.</p>
<p>We intentionally left out remediations for things that would likely break your system if attempted automatically in a one-size-fits-all approach (such as placing /etc and /tmp into their own partitions).</p>
<p>We also decided to add in an additional layer of testing; even though we have full confidence in Ansible's ability to declare changes accurately and idempotently, we did not want people who are new to the Ansible world to have to make any leap of faith (especially in the realm of security).</p>
<h2>Testing</h2>
<p>For testing we used the following components:</p>
<ul>
<li><a href="http://aws.amazon.com/">Amazon Web Services</a></li>
<li><a href="https://github.com/defionscode/STIGMA">STIGMA</a> (simple and highly effective, python program I wrote)</li>
<li><a href="https://codeship.com/">CodeShip</a></li>
<li><a href="http://ansible.com/">Ansible</a></li>
</ul>
<p>When trying to figure out the best and quickest way to test this, I came across a couple of decent challenges.</p>
<p>First, I <em>REALLY</em> <em>REALLY</em> did not want to host/manage my own CI server (think Jenkins, Bamboo, GoCD, etc). That left me with various SaaS-y options, I experimented with Drone, Codeship, and TravisCI; Codeship won me over. I felt their interface was more intuitive and it felt like the right balance of everything I needed (a topic for a future blog post), though I definitely think all three are very solid CI tools.</p>
<p>Second, there is currently no SaaS CI tool I could find which would let you test a server to the extent we needed in order to validate the application of the STIG. The solution was to have CodeShip install Ansible (and boto for the AWS modules) and have it clone a repository containing an Ansible playbook which would, at a high level:</p>
<ol>
<li>Launch the standard AWS provided RHEL6 AMI on an EC2 instance</li>
<li>Apply the STIG baselines (CAT 1, 2 and 3)</li>
<li>Run an OpenSCAP report and check the results via STIGMA</li>
<li>If the results are satisfactory to the standard, terminate the EC2 instance</li>
</ol>
<h2>Enter CodeShip</h2>
<p><img alt="CodeShip Setup" src="../codeship-1.png" /></p>
<p>This is the main screen you see after you import a project into CodeShip. IMO, this is an extremely straight forward interface. You simply write out in bash what you want to do for the setup and test processes.</p>
<p>For testing the STIG I used the following setup command stack:</p>
<pre class="code literal-block">curl -O http://keystored.on/some/really/secure.location/superkey &gt; /dev/null 2&gt;<span class="p">&amp;</span>1
chmod <span class="m">400</span> ./superkey
git clone git@github.com:ansible/ansible-lockdown.git lockdown
pip install -r ./lockdown/tests/requirements.txt
<span class="o">(</span><span class="nb">cd </span>lockdown/tests<span class="p">;</span> ansible-galaxy install -r requirements.yml<span class="o">)</span>
curl -o ./lockdown/tests/roles/post-test/files/stigma.py https://raw.githubusercontent.com/nousdefions/STIGMA/master/src/stigma.py
chmod +x ./lockdown/tests/roles/post-test/files/stigma.py
</pre>


<p>Let's go over what happens here in detail:</p>
<ul>
<li>First an insecure SSH key is downloaded from a server (this is the only use for the key, not used anywhere else) to the current working directory.</li>
<li>The permissions to the key are changed to 400 so that neither SSH nor Ansible error out due to permissive key issues.</li>
<li>The ansible-lockdown repository (which contains the testing code) is cloned into a directory called lockdown</li>
<li>Install the pip requirements.txt within the lockdown directory; boto and Ansible</li>
<li>The RHEL6-STIG role is installed via ansible-galaxy through a requirements.yml file (this is to both avoid overloading the lockdown repo with all the STIGs and to replicate the end user experience when using Galaxy). This file can be seen here.</li>
<li>STIGMA is downloaded into the roleâ€™s files directory (post-test) that calls it. The reason it is downloaded like this and not simply stored in the repo is to so that any updates made to STIGMA can happen seamlessly without having to manually update to the latest version.</li>
<li>Finally, execute permissions are added to STIGMA</li>
</ul>
<p>The testing portion is a simple one-liner:</p>
<pre class="code literal-block"><span class="o">(</span><span class="nb">cd </span>lockdown/tests<span class="p">;</span> ansible-playbook <span class="nb">test</span>-stigs.yml<span class="o">)</span>
</pre>


<p>This runs the playbook seen <a href="https://github.com/ansible/ansible-lockdown/blob/master/tests/test-stigs.yml">here</a>.</p>
<h2>Gotchas</h2>
<p>There were a couple of things that tripped me up while setting up this process. Here are the big ones:</p>
<ul>
<li>Curl behaves weird within CodeShip. Trying to use the -o option to specify where the file was to be downloaded to would error out unless the file already existed locally. You'll notice that stigma.py already exists within the testing repository as a blank file, for that purpose.</li>
<li>CodeShip has you work within a python virtualenv, which is fine, but creates issues with Ansible out of the box when trying to use modules that have pip dependencies since Ansible modules default to /usr/bin/python for the interpreter. In my case it was causing an ImportError for boto. The quick fix here is to add a line to the hosts file:</li>
</ul>
<p><code>localhost ansible_python_interpreter='/usr/bin/env python'</code></p>
<p>Naturally, any CI tool will have you work in a restricted environment (ie no sudo and no access to root level dirs). So when Ansible connects and tries to establish it's control path, it will error out with the default settings. This is the ansible config used for the testing:</p>
<pre class="code literal-block"><span class="k">[defaults]</span>
<span class="na">hostfile</span> <span class="o">=</span> <span class="s">./hosts</span>
<span class="na">private_key_file</span> <span class="o">=</span> <span class="s">../../insecure-CI</span>
<span class="na">host_key_checking</span> <span class="o">=</span> <span class="s">False</span>
<span class="na">display_skipped_hosts</span> <span class="o">=</span> <span class="s">False</span>

<span class="k">[ssh_connection]</span>
<span class="na">control_path</span> <span class="o">=</span> <span class="s">./ansible-ssh-%%h-%%p-%%r</span>
<span class="na">ssh_args</span> <span class="o">=</span>
</pre>


<p><strong>Important:</strong> Notice that host key checking is turned off. Without that option, any CI tool will hang at the accept hostkey prompt.</p>
<p>And that is all there is to it.
Comment below if you have any questions or there is something I missed which I should have included.</p>
<p>Cheers.</p>