<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quick Tips on Jonathan Davila</title>
    <link>https://davila.io/tags/quick-tips/</link>
    <description>Recent content in Quick Tips on Jonathan Davila</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Feb 2017 09:34:55 -0500</lastBuildDate>
    
	<atom:link href="https://davila.io/tags/quick-tips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Quick Tip: Making Ansible Execute Python Within a Virtualenv or Non Standard Path on Targets</title>
      <link>https://davila.io/posts/quick-tip-making-ansible-execute-python-within-a-virtualenv-or-non-standard-path-on-targets/</link>
      <pubDate>Mon, 06 Feb 2017 09:34:55 -0500</pubDate>
      
      <guid>https://davila.io/posts/quick-tip-making-ansible-execute-python-within-a-virtualenv-or-non-standard-path-on-targets/</guid>
      <description>One of the interesting things in Ansible-land is that all of the (non-Windows) modules in the upstream contain a very specific shebang, in particular #!/usr/bin/python.
As a result I’ve seen a few bad patterns in the wild:
 Symlinking the desired Python executable to /usr/bin/python
 Manually installing Python on that path
 Giving up and use the raw module
  Good news, you don’t need to do any of that.</description>
    </item>
    
  </channel>
</rss>