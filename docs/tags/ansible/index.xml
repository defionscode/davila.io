<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ansible on Jonathan Davila</title>
    <link>https://davila.io/tags/ansible/</link>
    <description>Recent content in Ansible on Jonathan Davila</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Jul 2018 10:18:22 -0500</lastBuildDate>
    
	<atom:link href="https://davila.io/tags/ansible/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>30 Lies Puppetlabs Made About Ansible, #25 Will Shock You</title>
      <link>https://davila.io/posts/30-lies-puppetlabs-made-about-ansible-25-will-shock-you/</link>
      <pubDate>Wed, 11 Jul 2018 10:18:22 -0500</pubDate>
      
      <guid>https://davila.io/posts/30-lies-puppetlabs-made-about-ansible-25-will-shock-you/</guid>
      <description>Disclaimer: While I was once an employee of Red Hat and Ansible. I am not employed by Red Hat anymore and this blog post was not sanctioned or endorsed by Red Hat in any way.
 On June 26th, 2018, PuppetLabs via their Twitter account made the following tweet

If you rather not go through their form-wall you can get it directly here https://puppet.com/system/files/2018-06/puppet-wp-compare-puppet-and-ansible.pdf
This tweet sparked my interest.</description>
    </item>
    
    <item>
      <title>Quick Tip: Making Ansible Execute Python Within a Virtualenv or Non Standard Path on Targets</title>
      <link>https://davila.io/posts/quick-tip-making-ansible-execute-python-within-a-virtualenv-or-non-standard-path-on-targets/</link>
      <pubDate>Mon, 06 Feb 2017 09:34:55 -0500</pubDate>
      
      <guid>https://davila.io/posts/quick-tip-making-ansible-execute-python-within-a-virtualenv-or-non-standard-path-on-targets/</guid>
      <description>One of the interesting things in Ansible-land is that all of the (non-Windows) modules in the upstream contain a very specific shebang, in particular #!/usr/bin/python.
As a result I’ve seen a few bad patterns in the wild:
 Symlinking the desired Python executable to /usr/bin/python
 Manually installing Python on that path
 Giving up and use the raw module
  Good news, you don’t need to do any of that.</description>
    </item>
    
  </channel>
</rss>